/*!
 * Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
export interface MetricBase {
    /** The result of the operation */
    readonly result: Result
    /** The duration of the operation in miliseconds */
    readonly duration: number
    /** A flag indicating that the metric was not caused by the user. */
    readonly passive: boolean
}

export interface MetadataHasResult extends MetricBase {}

export type Result = 'Succeeded'
export type LambdaRuntime = 'dotnetcore2.1' | 'nodejs12.x'

export interface MetricDefinition {
    readonly passive: boolean
    readonly requiredMetadata: readonly string[]
}

export abstract class Metric<T extends MetricBase = MetricBase> {
    protected readonly state: Record<string, unknown> = {}

    public constructor(public readonly name: string, public readonly definition: MetricDefinition) {}

    public record(data: Partial<T>): this {
        Object.assign(this.state, data)
        return this
    }

    public abstract submit(): void
}

export class Telemetry {
    private constructor(protected readonly getMetric: (name: string, definition: MetricDefinition) => Metric) {}

    /** It does not actually have a result, yep */
    public usingMetadataHasResult(): Metric<MetadataHasResult> {
        return this.getMetric('metadata_hasResult', { passive: false, requiredMetadata: [] })
    }
}

export interface MetricShapes {
    readonly metadata_hasResult: MetadataHasResult
}

export type MetricName = keyof MetricShapes
