/*!
 * Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
export interface MetricBase {
    /** The result of the operation */
    readonly result?: Result
    /** The reason for a metric or exception depending on context */
    readonly reason?: string
    /** The duration of the operation in miliseconds */
    readonly duration?: number
    /** A flag indicating that the metric was not caused by the user. */
    readonly passive?: boolean
    /** @deprecated Arbitrary "value" of the metric. */
    readonly value?: number
}

export interface MetadataHasResult extends MetricBase {}

export type Result = 'Succeeded'
export type LambdaRuntime = 'dotnetcore2.1' | 'nodejs12.x'

export interface MetricDefinition {
    readonly unit: string
    readonly passive: boolean
    readonly requiredMetadata: readonly string[]
}

export interface MetricShapes {
    readonly metadata_hasResult: MetadataHasResult
}

export type MetricName = keyof MetricShapes

const definitions: Record<string, MetricDefinition> = {
    metadata_hasResult: { unit: 'None', passive: false, requiredMetadata: [] },
}

export type Metadata<T extends MetricBase> = Partial<Omit<T, keyof MetricBase>>

export abstract class Metric<T extends MetricBase = MetricBase> {
    protected readonly state: Partial<T> = {}
    protected readonly definition: MetricDefinition = definitions[this.name] ?? {
        unit: 'None',
        passive: true,
        requiredMetadata: [],
    }

    public constructor(public readonly name: string) {}

    public abstract record(data: Metadata<T>): this

    public abstract emit(data?: T): void
}

export abstract class TelemetryBase {
    /** It does not actually have a result, yep */
    public get metadata_hasResult(): Metric<MetadataHasResult> {
        return this.getMetric('metadata_hasResult')
    }

    protected abstract getMetric(name: string): Metric
}
